name: Build & Deploy Community

on:
  workflow_dispatch:
    inputs:
      bucket:
        description: "Nombre del bucket GCS (sin gs://)"
        required: true
        type: string
      prefix:
        description: "Prefijo de carpeta (ej: barrios-caba-map-v2025)"
        required: true
        type: string
      version:
        description: "Versión (ej: m, v2025-08-17, etc.)"
        required: true
        type: string
      devMode:
        description: "Habilitar devMode en el manifest"
        required: false
        default: "false"
        type: string
      scheme:
        description: "Esquema para packageUrl/resources (gs|https)"
        required: false
        default: "gs"
        type: string
      configName:
        description: "Nombre del config (default: config.json)"
        required: false
        default: "config.json"
        type: string
      setIdToFolder:
        description: "Usar <prefix>-<version> como id del componente"
        required: false
        default: "true"
        type: string
      manifestPath:
        description: "Ruta de salida del manifest (default: public/manifest.json)"
        required: false
        default: "public/manifest.json"
        type: string

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    env:
      BUCKET: ${{ inputs.bucket }}
      PREFIX: ${{ inputs.prefix }}
      VERSION: ${{ inputs.version }}
      DEV_MODE: ${{ inputs.devMode }}
      SCHEME: ${{ inputs.scheme }}
      CONFIG_NAME: ${{ inputs.configName }}
      SET_ID_TO_FOLDER: ${{ inputs.setIdToFolder }}
      MANIFEST_PATH: ${{ inputs.manifestPath }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps
        run: npm ci

      - name: Build (si existe script)
        run: |
          if npm run | grep -qE '^  build'; then
            npm run build
          else
            echo "No hay script build, continuo..."
          fi

      # ---------- Auth con Workload Identity ----------
      - name: "Auth to Google Cloud (WIF)"
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: "Setup gcloud SDK"
        uses: google-github-actions/setup-gcloud@v2

      # ---------- Generar manifest coherente (usa tu prepare-version.mjs) ----------
      - name: "Generar manifest (limpio y scheme coherente)"
        run: |
          node scripts/prepare-version.mjs \
            --bucket "${BUCKET}" \
            --prefix "${PREFIX}" \
            --version "${VERSION}" \
            --devMode "${DEV_MODE}" \
            --scheme "${SCHEME}" \
            --configName "${CONFIG_NAME}" \
            --setIdToFolder "${SET_ID_TO_FOLDER}" \
            --manifestPath "${MANIFEST_PATH}"

      # ---------- Calcular carpeta/PKG_PATH con sanitizado (SIN Python) ----------
      - name: Compute package path (sanitized, bash)
        id: pkg
        shell: bash
        run: |
          set -Eeuo pipefail
          sanitize_str() {
            local s="$1"
            local NBSP=$'\u00A0'
            local EXTRAS=$'\u200B\u200C\u200D\uFEFF\u202F\u205F\u3000\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A'
            s="${s//${NBSP}/}"
            local ch
            while IFS= read -r -n1 ch; do [ -z "$ch" ] && continue; s="${s//${ch}/}"; done <<<"$EXTRAS"
            s="${s//[[:space:]]/}"
            s="$(printf '%s' "$s" | sed -E 's/[^A-Za-z0-9._-]//g')"
            printf '%s' "$s"
          }
          RAW_PREFIX="${PREFIX}"
          RAW_VERSION="${VERSION}"
          PFX="$(sanitize_str "$RAW_PREFIX")"
          VER="$(sanitize_str "$RAW_VERSION")"
          if [[ -z "$PFX" || -z "$VER" ]]; then
            echo "::error ::prefix/version vacíos tras sanitizar (prefix='${RAW_PREFIX}', version='${RAW_VERSION}')"
            exit 1
          fi
          FOLDER="${PFX}-${VER}"
          PKG_PATH="gs://${BUCKET}/${FOLDER}/"
          echo "PFX(raw -> clean): '${RAW_PREFIX}' -> '${PFX}'"
          echo "VER(raw -> clean): '${RAW_VERSION}' -> '${VER}'"
          echo "FOLDER: ${FOLDER}"
          echo "PKG_PATH: ${PKG_PATH}"
          echo "FOLDER=${FOLDER}"     >> "$GITHUB_OUTPUT"
          echo "PKG_PATH=${PKG_PATH}" >> "$GITHUB_OUTPUT"
          echo "FOLDER=${FOLDER}"     >> "$GITHUB_ENV"
          echo "PKG_PATH=${PKG_PATH}" >> "$GITHUB_ENV"

      - name: Mostrar manifest (debug)
        shell: bash
        run: |
          echo "::group::manifest.json (head)"
          if [ -f "${MANIFEST_PATH}" ]; then
            head -n 80 "${MANIFEST_PATH}"
          else
            echo "No existe ${MANIFEST_PATH}"
            echo "Contenido de $(dirname "${MANIFEST_PATH}")"
            ls -la "$(dirname "${MANIFEST_PATH}")" || true
          fi
          echo "::endgroup::"

      # ---------- Validar que manifest.packageUrl == carpeta esperada (sin jq) ----------
      - name: Assert manifest/packageUrl matches expected
        shell: bash
        run: |
          set -Eeuo pipefail
          node -e "const fs=require('fs'),path=require('path'); const p=path.resolve(process.env.MANIFEST_PATH); if(!fs.existsSync(p)){ console.error('Manifest no encontrado en:', p); process.exit(2); } const j=JSON.parse(fs.readFileSync(p,'utf8')); console.log('[debug] packageUrl:', j.packageUrl); console.log('[debug] manifestPath:', p);"
          HAVE="$(node -e "const fs=require('fs'),path=require('path'); const p=path.resolve(process.env.MANIFEST_PATH); const j=JSON.parse(fs.readFileSync(p,'utf8')); process.stdout.write(String(j.packageUrl||''));")"
          if [[ "${SCHEME}" == "gs" ]]; then
            EXPECT="${PKG_PATH}"
          else
            EXPECT="https://storage.googleapis.com/${BUCKET}/${FOLDER}/"
          fi
          echo "packageUrl (manifest): ${HAVE}"
          echo "Esperado (por scheme): ${EXPECT}"
          if [[ "${HAVE}" != "${EXPECT}" ]]; then
            echo "::error ::El packageUrl del manifest NO coincide con la carpeta esperada."
            exit 1
          fi

      # ---------- Subidas ----------
      - name: Upload JS
        run: |
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/javascript" \
            cp dist/Visualization.js "${PKG_PATH}Visualization.js"

      - name: Upload CSS (si existe)
        run: |
          if [ -f dist/Visualization.css ]; then
            gsutil -m -h "Cache-Control:no-store" -h "Content-Type: text/css" \
              cp dist/Visualization.css "${PKG_PATH}Visualization.css"
          else
            echo "No hay Visualization.css, se omite."
          fi

      - name: Upload config.json
        shell: bash
        run: |
          set -Eeuo pipefail
          CFG_PATH="${MANIFEST_PATH%/*}/${CONFIG_NAME}"
          if [ ! -f "$CFG_PATH" ]; then
            if [ -f "public/${CONFIG_NAME}" ]; then
              CFG_PATH="public/${CONFIG_NAME}"
            else
              echo "::error ::No se encontró ${CONFIG_NAME} en ${MANIFEST_PATH%/*} ni en public/"
              exit 1
            fi
          fi
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/json" \
            cp "$CFG_PATH" "${PKG_PATH}${CONFIG_NAME}"

      - name: Upload manifest.json
        run: |
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/json" \
            cp "${MANIFEST_PATH}" "${PKG_PATH}manifest.json"

      # ---------- Post-deploy ----------
      - name: Listar carpeta y mostrar packageUrl subido
        run: |
          gsutil ls -l "${PKG_PATH}"
          echo "packageUrl (subido):"
          gsutil cp "${PKG_PATH}manifest.json" - | node -e "process.stdin.once('data',b=>{const j=JSON.parse(b.toString());console.log(j.packageUrl)})"
