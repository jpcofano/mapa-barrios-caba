name: Build & Deploy Community Viz

on:
  workflow_dispatch:
    inputs:
      prefix:
        description: "Carpeta de destino en GCS (ej: barrios-caba-map-v2025)"
        required: true
        default: "barrios-caba-map-v2025"
      version:
        description: "Sufijo de versi√≥n (ej: m). Si est√° vac√≠o, no agrega sufijo."
        required: false
        default: ""
      devMode:
        description: "Forzar devMode en manifest (true|false, opcional)"
        required: false
        default: ""
      bucket:
        description: "Bucket GCS (sin gs://)"
        required: true
        default: "mapa-barrios-degcba"
      scheme:
        description: "Esquema para resources (https|gs)"
        required: false
        default: "https"
      configName:
        description: "Nombre del config (normalizar a min√∫scula)"
        required: false
        default: "config.json"

permissions:
  contents: read
  id-token: write   # requerido para Workload Identity Federation (auth@v2)

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      NODE_VERSION: "20"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install deps
        run: npm ci

      # Normaliza a config.json en min√∫scula si vino como Config.json
      - name: Ensure config.json lowercase
        run: |
          if [ -f public/Config.json ] && [ ! -f public/config.json ]; then
            cp public/Config.json public/config.json
          fi
          test -f public/config.json

      # Prepara carpeta destino y actualiza manifest/rutas (si falta arg, corta)
      - name: Prepare version
        run: |
          set -e
          ARGS=( --bucket "${{ inputs.bucket }}"
                 --prefix "${{ inputs.prefix }}"
                 --scheme "${{ inputs.scheme }}"
                 --configName "${{ inputs.configName }}"
                 --setIdToFolder "true"
                 --manifestPath "public/manifest.json" )
          if [ -n "${{ inputs.version }}" ]; then ARGS+=( --version "${{ inputs.version }}" ); fi
          if [ -n "${{ inputs.devMode }}" ]; then ARGS+=( --devMode "${{ inputs.devMode }}" ); fi
          echo "node scripts/prepare-version.mjs ${ARGS[*]}"
          node scripts/prepare-version.mjs "${ARGS[@]}"
          echo "==== manifest.json (result) ===="
          cat public/manifest.json

      - name: Build (Vite)
        run: npm run build

      # Sanitizar manifest (NBSP/zero-width) y verificar
      - name: Sanitize manifest (inline)
        run: |
          node -e "const fs=require('fs');let t=fs.readFileSync('public/manifest.json','utf8');t=t.replace(/[\u00A0\u1680\u2000-\u200D\u202F\u205F\u2060\u3000\uFEFF]/g,' ').replace(/[\t\r\n]+/g,' ').replace(/\s{2,}/g,' ').trim();fs.writeFileSync('public/manifest.json',t)"
      - name: Check manifest for NBSP/ZW
        run: |
          node -e "const s=require('fs').readFileSync('public/manifest.json','utf8');if(/[\u00A0\u1680\u2000-\u200D\u202F\u205F\u2060\u3000\uFEFF]/.test(s)){console.error('NBSP/zero-width detectado en manifest.json');process.exit(1)}"

      # Assert single bundle
      - name: Assert single bundle (no dynamic import)
        run: |
          test -f dist/Visualization.js
          if grep -q "import(" dist/Visualization.js; then
            echo "‚ùå import() din√°micos en bundle"; exit 1
          else
            echo "‚úÖ Sin import() din√°micos"
          fi
          if grep -qi "subscribeToData" dist/Visualization.js; then
            echo "‚úÖ dscc parece bundleado (subscribeToData detectado)"
          else
            echo "‚ÑπÔ∏è No se encontr√≥ 'subscribeToData' (puede estar minificado); seguimos"
          fi

      # üîê AUTH con WIF (tu forma). Exporta outputs para gsutil.
      - name: Auth to Google Cloud (WIF)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          export_environment_variables: true   # expone GOOGLE_GHA_CREDS_PATH / credentials_file_path

      - name: Setup gcloud (con gsutil)
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          install_components: gsutil

      # Forzar que gsutil use las credenciales de WIF (evita 401 Anonymous)
      - name: Export ADC env for gsutil
        run: |
          echo "GOOGLE_APPLICATION_CREDENTIALS=${{ steps.auth.outputs.credentials_file_path }}" >> $GITHUB_ENV
          echo "CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE=${{ steps.auth.outputs.credentials_file_path }}" >> $GITHUB_ENV

      # üëÄ Sanity check (gcloud usa ADC/WIF; gsutil tambi√©n por override)
      - name: Auth & Bucket check
        env:
          B: ${{ inputs.bucket }}
        run: |
          set -e
          echo "ADC file: $GOOGLE_APPLICATION_CREDENTIALS"
          test -f "$GOOGLE_APPLICATION_CREDENTIALS"
          echo "gcloud version:" && gcloud version
          echo "Auth list (con WIF puede salir vac√≠o y es OK):" && gcloud auth list || true
          echo "Access token (recortado):" && gcloud auth print-access-token | head -c 20 && echo "..."
          echo "gsutil ls -b gs://$B:" && gsutil ls -b gs://$B

      # Armar FOLDER y BUCKET_PATH (sin depender de .bucket_path)
      - name: Compute BUCKET_PATH
        run: |
          FOLDER="${{ inputs.prefix }}"
          if [ -n "${{ inputs.version }}" ]; then FOLDER="${{ inputs.prefix }}-${{ inputs.version }}"; fi
          echo "FOLDER=$FOLDER" >> $GITHUB_ENV
          echo "BUCKET_PATH=gs://${{ inputs.bucket }}/$FOLDER" >> $GITHUB_ENV
          echo "BUCKET_PATH=gs://${{ inputs.bucket }}/$FOLDER"

      # üöÄ Deploy con gsutil (usa ADC por env override). No-store + tipos correctos.
      - name: Deploy to GCS
        run: |
          set -e
          echo "Deploying to $BUCKET_PATH"

          # JS
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/javascript" \
            cp dist/Visualization.js "$BUCKET_PATH/Visualization.js"

          # CSS
          if [ -f dist/Visualization.css ]; then
            gsutil -m -h "Cache-Control:no-store" -h "Content-Type: text/css" \
              cp dist/Visualization.css "$BUCKET_PATH/Visualization.css"
          fi

          # config.json (min√∫scula)
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/json" \
            cp public/config.json "$BUCKET_PATH/config.json"

          # manifest.json
          gsutil -m -h "Cache-Control:no-store" -h "Content-Type: application/json" \
            cp public/manifest.json "$BUCKET_PATH/manifest.json"

          # Est√°ticos opcionales (no-store para simplificar pruebas)
          if [ -f public/Icon.png ]; then
            gsutil -m -h "Cache-Control:no-store" -h "Content-Type: image/png" \
              cp public/Icon.png "$BUCKET_PATH/Icon.png"
          fi
          if [ -f public/Logo.png ]; then
            gsutil -m -h "Cache-Control:no-store" -h "Content-Type: image/png" \
              cp public/Logo.png "$BUCKET_PATH/Logo.png"
          fi

      # Verificaci√≥n r√°pida por HTTP (HEAD)
      - name: Verify HEAD (HTTP)
        run: |
          for u in \
            "https://storage.googleapis.com/${{ inputs.bucket }}/$FOLDER/manifest.json" \
            "https://storage.googleapis.com/${{ inputs.bucket }}/$FOLDER/config.json" \
            "https://storage.googleapis.com/${{ inputs.bucket }}/$FOLDER/Visualization.js" \
            "https://storage.googleapis.com/${{ inputs.bucket }}/$FOLDER/Visualization.css"
          do
            echo "::group::HEAD $u"
            curl -I -sS "$u" | sed -n '1p;/^content-type:/Ip;/^cache-control:/Ip'
            echo "::endgroup::"
          done
